/**
 * Shared Zod validation schemas for DTOs (Data Transfer Objects)
 * 
 * These schemas define what the API accepts from the frontend.
 * They may exclude fields that the backend sets automatically (e.g., id, createdAt, isVerified).
 * 
 * Usage:
 * - Backend: Use for request validation in routes
 * - Frontend: Use for form validation and type inference
 * - Single source of truth for validation rules
 */

import { z } from 'zod';

// ============================================================================
// Accounting Schemas
// ============================================================================

export const chartOfAccountsTypeSchema = z.enum(['asset', 'liability', 'equity', 'revenue', 'expense']);

export const createChartOfAccountsSchema = z.object({
  code: z.string().min(1, 'Account code is required'),
  name: z.string().min(1, 'Account name is required'),
  type: chartOfAccountsTypeSchema,
  parentId: z.string().optional().nullable(),
  isGroup: z.boolean().default(false),
  nfrsMap: z.string().optional().nullable(),
  isActive: z.boolean().default(true),
  // Note: cooperativeId is set by backend from request context
  // Note: mappedUserId is optional and set separately
});

export const updateChartOfAccountsSchema = z.object({
  code: z.string().min(1).optional(),
  name: z.string().min(1).optional(),
  type: chartOfAccountsTypeSchema.optional(),
  parentId: z.string().optional().nullable(),
  isGroup: z.boolean().optional(),
  nfrsMap: z.string().optional().nullable(),
  isActive: z.boolean().optional(),
});

export const createJournalEntrySchema = z.object({
  entryNumber: z.string().min(1, 'Entry number is required'),
  description: z.string().min(1, 'Description is required'),
  date: z.string().datetime().or(z.date()),
  ledgerEntries: z.array(
    z.object({
      accountId: z.string().min(1, 'Account ID is required'),
      debit: z.number().nonnegative().default(0),
      credit: z.number().nonnegative().default(0),
    })
  ).min(2, 'At least two ledger entries required'),
}).refine(
  (data) => {
    const totalDebit = data.ledgerEntries.reduce((sum, entry) => sum + entry.debit, 0);
    const totalCredit = data.ledgerEntries.reduce((sum, entry) => sum + entry.credit, 0);
    return totalDebit === totalCredit;
  },
  {
    message: 'Total debit must equal total credit',
    path: ['ledgerEntries'],
  }
);

export const createTransactionSchema = z.object({
  transactionNumber: z.string().min(1, 'Transaction number is required'),
  description: z.string().min(1, 'Description is required'),
  amount: z.number().positive('Amount must be positive'),
  type: z.enum(['debit', 'credit']),
  date: z.string().datetime().or(z.date()),
  accountId: z.string().min(1, 'Account ID is required'),
});

// ============================================================================
// Savings Schemas
// ============================================================================

export const interestPostingFrequencySchema = z.enum(['QUARTERLY', 'ANNUALLY', 'MONTHLY']);
export const interestCalculationMethodSchema = z.enum(['DAILY_BALANCE', 'AVERAGE_BALANCE']);

export const createSavingProductSchema = z.object({
  code: z.string().min(1, 'Product code is required'),
  name: z.string().min(1, 'Product name is required'),
  description: z.string().optional(),
  interestRate: z.number().min(0).max(100, 'Interest rate must be between 0 and 100'),
  minimumBalance: z.number().nonnegative().default(0),
  interestPostingFrequency: interestPostingFrequencySchema.default('QUARTERLY'),
  interestCalculationMethod: interestCalculationMethodSchema.default('DAILY_BALANCE'),
  isTaxApplicable: z.boolean().default(true),
  taxRate: z.number().min(0).max(100).default(6.0),
  isActive: z.boolean().default(true),
});

export const updateSavingProductSchema = createSavingProductSchema.partial();

export const createSavingAccountSchema = z.object({
  memberId: z.string().min(1, 'Member ID is required'),
  productId: z.string().min(1, 'Product ID is required'),
  initialDeposit: z.number().nonnegative().default(0),
  nominee: z.object({
    name: z.string().min(1),
    relation: z.string().min(1),
    citizenship: z.string().optional(),
    photo: z.string().optional(),
  }).optional(),
  // Note: accountNumber is generated by backend
  // Note: openedDate defaults to now
});

export const savingAccountTransactionSchema = z.object({
  accountId: z.string().min(1, 'Account ID is required'),
  amount: z.number().positive('Amount must be positive'),
  type: z.enum(['deposit', 'withdrawal']),
  description: z.string().optional(),
  date: z.string().datetime().or(z.date()).optional(),
});

// ============================================================================
// Loan Schemas
// ============================================================================

export const createLoanProductSchema = z.object({
  code: z.string().min(1, 'Product code is required'),
  name: z.string().min(1, 'Product name is required'),
  description: z.string().optional(),
  interestRate: z.number().min(0).max(100, 'Interest rate must be between 0 and 100'),
  maxLoanAmount: z.number().positive('Max loan amount must be positive'),
  minLoanAmount: z.number().nonnegative().default(0),
  maxTenureMonths: z.number().int().positive('Max tenure must be positive'),
  minTenureMonths: z.number().int().positive().default(1),
  processingFee: z.number().nonnegative().default(0),
  isActive: z.boolean().default(true),
});

export const updateLoanProductSchema = createLoanProductSchema.partial();

export const createLoanApplicationSchema = z.object({
  memberId: z.string().min(1, 'Member ID is required'),
  productId: z.string().min(1, 'Product ID is required'),
  loanAmount: z.number().positive('Loan amount must be positive'),
  tenureMonths: z.number().int().positive('Tenure must be positive'),
  purpose: z.string().optional(),
  // Note: interestRate is taken from product, but can be overridden
  interestRate: z.number().min(0).max(100).optional(),
  // Note: applicationNumber is generated by backend
});

export const updateLoanApplicationStatusSchema = z.object({
  status: z.enum(['pending', 'approved', 'rejected', 'disbursed', 'closed']),
  remarks: z.string().optional(),
});

export const disburseLoanSchema = z.object({
  applicationId: z.string().min(1, 'Application ID is required'),
  disbursedDate: z.string().datetime().or(z.date()).optional(),
  remarks: z.string().optional(),
});

// ============================================================================
// HRM Schemas
// ============================================================================

export const createEmployeeSchema = z.object({
  userId: z.string().optional().nullable(),
  code: z.string().min(1, 'Employee code is required'),
  firstName: z.string().min(1, 'First name is required'),
  lastName: z.string().min(1, 'Last name is required'),
  departmentId: z.string().min(1, 'Department ID is required'),
  designationId: z.string().min(1, 'Designation ID is required'),
  joinDate: z.string().datetime().or(z.date()),
  basicSalary: z.number().nonnegative('Basic salary must be non-negative'),
  defaultShiftId: z.string().optional().nullable(),
});

export const updateEmployeeSchema = createEmployeeSchema.partial();

export const createLeaveRequestSchema = z.object({
  employeeId: z.string().min(1, 'Employee ID is required'),
  leaveTypeId: z.string().min(1, 'Leave type ID is required'),
  startDate: z.string().datetime().or(z.date()),
  endDate: z.string().datetime().or(z.date()),
  comment: z.string().optional(),
}).refine(
  (data) => {
    const start = new Date(data.startDate);
    const end = new Date(data.endDate);
    return end >= start;
  },
  {
    message: 'End date must be after or equal to start date',
    path: ['endDate'],
  }
);

export const updateLeaveRequestStatusSchema = z.object({
  status: z.enum(['PENDING', 'APPROVED', 'REJECTED']),
  comment: z.string().optional(),
});

export const createPayrollRunSchema = z.object({
  fiscalYear: z.string().min(1, 'Fiscal year is required'),
  monthBs: z.number().int().min(1).max(12, 'Month must be between 1 and 12'),
});

// ============================================================================
// Compliance Schemas
// ============================================================================

export const riskCategorySchema = z.enum(['LOW', 'MEDIUM', 'HIGH']);

export const updateMemberRiskCategorySchema = z.object({
  memberId: z.string().min(1, 'Member ID is required'),
  riskCategory: riskCategorySchema,
  remarks: z.string().optional(),
});

export const createAmlCaseSchema = z.object({
  memberId: z.string().min(1, 'Member ID is required'),
  caseType: z.string().min(1, 'Case type is required'),
  description: z.string().min(1, 'Description is required'),
  priority: z.enum(['LOW', 'MEDIUM', 'HIGH']).default('MEDIUM'),
});

export const updateAmlCaseStatusSchema = z.object({
  status: z.enum(['OPEN', 'INVESTIGATING', 'RESOLVED', 'CLOSED']),
  remarks: z.string().optional(),
});

// ============================================================================
// Governance Schemas
// ============================================================================

export const meetingTypeSchema = z.enum(['BOD', 'AGM', 'EGM', 'COMMITTEE', 'OTHER']);

export const createMeetingSchema = z.object({
  type: meetingTypeSchema,
  title: z.string().min(1, 'Meeting title is required'),
  description: z.string().optional(),
  scheduledDate: z.string().datetime().or(z.date()),
  location: z.string().optional(),
  agenda: z.string().optional(),
  committeeId: z.string().optional().nullable(),
});

export const updateMeetingStatusSchema = z.object({
  status: z.enum(['PLANNED', 'SCHEDULED', 'COMPLETED', 'CANCELLED']),
  remarks: z.string().optional(),
});

export const createCommitteeSchema = z.object({
  name: z.string().min(1, 'Committee name is required'),
  type: z.enum(['BOD', 'ACCOUNT', 'LOAN', 'EDUCATION', 'OTHER']),
  description: z.string().optional(),
  memberIds: z.array(z.string()).optional(),
});

// ============================================================================
// Share Schemas
// ============================================================================

export const issueSharesSchema = z.object({
  memberId: z.string().min(1, 'Member ID is required'),
  kitta: z.number().int().positive('Kitta must be a positive integer'),
  date: z.string().datetime().or(z.date()),
  paymentMode: z.enum(['CASH', 'BANK', 'SAVING']),
  bankAccountId: z.string().optional(),
  savingAccountId: z.string().optional(),
  remarks: z.string().optional(),
});

export const returnSharesSchema = z.object({
  memberId: z.string().min(1, 'Member ID is required'),
  kitta: z.number().int().positive('Kitta must be a positive integer'),
  date: z.string().datetime().or(z.date()),
  paymentMode: z.enum(['CASH', 'BANK']),
  bankAccountId: z.string().optional(),
  remarks: z.string().optional(),
});

export const transferSharesSchema = z.object({
  fromMemberId: z.string().min(1, 'From member ID is required'),
  toMemberId: z.string().min(1, 'To member ID is required'),
  kitta: z.number().int().positive('Kitta must be a positive integer'),
  date: z.string().datetime().or(z.date()),
  remarks: z.string().optional(),
}).refine(
  (data) => data.fromMemberId !== data.toMemberId,
  {
    message: 'Cannot transfer shares to the same member',
    path: ['toMemberId'],
  }
);

export const issueBonusSharesSchema = z.object({
  memberId: z.string().min(1, 'Member ID is required'),
  kitta: z.number().int().positive('Kitta must be a positive integer'),
  date: z.string().datetime().or(z.date()),
  remarks: z.string().optional(),
});

// ============================================================================
// Workflow Schemas
// ============================================================================

export const workflowTransitionSchema = z.object({
  from: z.string().min(1, 'From state is required'),
  to: z.string().min(1, 'To state is required'),
  remarks: z.string().optional(),
});

// ============================================================================
// Export all schemas
// ============================================================================

// Re-export existing member schemas for convenience
export { createMemberSchema, updateMemberSchema, updateMemberStatusSchema } from './index';

